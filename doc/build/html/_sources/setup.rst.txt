Setup
=====

Hardware
~~~~~~~~

PSUs
----

The Phased Array requires a lot of different power channels, and, in the absence of a dedicated PSU board (which is on the list of things to do!), requires a complicated PSU setup.

The main issue is that to generate all the voltage, isolated power supplies need to be used, and only at one point should ground be referenced to earth ground. This helps avoid ground loops. In general, the principle of "star grounding" should be followed as much as possible to avoid signal integrity issues (although we have issues with this, like the ground connections on our i2c/sync bus).

In the past, +/- 40V was generated with two `VOLTEQ HY5005D` power supplies. The positive of one was linked to the negative of the other, with that point being the ground reference, in order to generate both a positive and negative voltage. Each PSU should draw approximately .5A when all power amps on the channel boards are powered. Note that these rails only power those power amps and central tx/rx switch, so those PSUs don't need to be on when debugging the MCUs or the receive chain! Furthermore, The power amps we use right now have their heatsinks at -40V, so be careful touching anything (such as probe ground leads, which are earth referenced) to them when these PSUs are on!!

The 15V rail was generated with a `CircuitSpecialists.com CSI5003X5` PSU. This was set to only 9V, since the 15V rail just gets regulated down to 3v3 (for the MCU) and 5v (for the opamps), and setting it to 9V lets the hydrophone preamp get powered off of it, if necessary. This should draw a little over an amp with everything on, so the `Agilent E3630A` PSUs that are usually in the tank room *won't* work for this!

The -15V rail was generated with an incredibly massive and sketchy PSU (it was unregulated, so it's voltage was a function of current draw). I would recommend looking for another PSU, but again it needs to handle more than .5A of power (the Agilent PSU didn't work). This rail powers just the opamps in the tx and rx chain.

The ft2232h chip and the 556 timer are driven from the USB bus. Note that when everything is powered, The chip will still have power via USB, which it might try to use to "back power" some of the MCUs via the i2c rail. A similar situation happens with the jlink chip. Disconnect these when turning power off to the array.

Make sure to use a multimeter to check that there is no continuity between any of the rails before powering everything on!

ft2232h
-------
This chip is now what we use to connect to the computers via the i2c connection. We switched in spring 2021 since the buspirate was very slow, especially when reading the large amounts of data during an rx sequence. We used the `ft2232h-56Q` evaluation board the whole time so that we did not have to deal with rolling our own board. Note, however, that this solution is still suboptimal, since the FT2232H cannot tri-state the buffer (see `pyftdi documentation`_). Furthermore, i2c over such long distances with so many devices isn't great for neither EMI nor rise-times (due to bus capacitance). It is generally a pretty slow communications protocol, so in the future, we are trying to switch.

The i2c read/writes fail occasionally, and we make sure to allow for many re-tries when things go wrong, as well as check the integrity of read data with a crc32 checksum. If an i2c or checksum error occurs, it usually resolves within 10 tries, but very rarely takes longer. It has never taken 50!

See below for i2c wiring (also documented in pyftdi_)

.. _pyftdi: https://eblot.github.io/pyftdi/api/i2c.html#wiring
.. _`pyftdi documentation`: https://eblot.github.io/pyftdi/api/i2c.html#open-collector-bus 


.. figure:: figs/i2c_wiring.png
  :width: 400
  :alt: I2C wiring

  Fig.1: FT2232H i2c wiring. note the `FT_` prefix won't appear on the silkscreen of the `FT2232H-56Q` itself. The pullups on the bus are implemented as bodge jobs on channel board 9, soldered to the output of it's 3v3 regulator. In the future, powering them off the 3v3 rail from the `ft2232h-56q`  is most likely a better idea.


The sync pulse is also generated by the GPIO of the `ft2232h`, and is used by all boards to start a tx at the exact same time, and an rx at the exact same time. This extremely important to the operation of the phased array since any small delay introduced between the starts of tx/rx for different boards will mess up beamforming. The MCU clocks are not exactly the same, so we provide a sync pulse for both the start of the tx and the start of the rx, to "re-sync" the MCUs). The rising edge of the sync pulse controls a tx start, and the falling edge controls an rx start. We need to have a deterministic and price amount of time between the start of a tx and the start of an rx, since this delay has to be taken into account when range-finding. Furthermore, we want to be able vary the amount of time between the start of a tx and the start of an rx sequence, since having some delay between the end of the tx and the start of the rx allows the piezos to stop "ringing" before getting ready to receive the pulse. In practice, this just effects the minimum range that the phased array can image. the FT2232H cannot provide the deterministic timing for the sync pulse because it is controlled via USB by a non real time operating system (e.g. your computer), so the pulse width is non-deterministic. We solve this by using a 555 timer in a `monostable configuration`_, with a trim potentiometer to allow us to vary the pulse width. In practice, the stock room only has a 556 timer (basically two 555 timers in the same package), so we used this with some pins disconnected. See the wiring diagram:

.. _`monostable configuration`: https://www.electronics-tutorials.ws/waveforms/555_timer.html


.. figure:: figs/556_wiring.png
  :width: 400
  :alt: 556 wiring for sync pulse generation.

  Fig.2: 556 wiring for sync pulse generation. This was done on the breadboard next to channel 1.
  

The entire wiring schematic (and kicad project file) can be found at
``./figs/fish-n-chips-ft2232h``


fn generator
~~~~~~~~~~~~
We use a synced clock (bodge job) for the ADCs. Use a function generator for 1MHz square wave hooked up to the green clock distribution network. It should come in on extraio2.


Piezos
------
The wires for the piezos can be screwed into the central channel board by matching the number on the masking tape on the wire to the number on the label next to the channel board that the number corresponds to. These two digit numbers were meant to correspond to the row, col position of each piezo, but in reality, it's flipped. Note that the channel numbers on the central board do not correspond to any sort of channel location or i2c address, they are only internal to the switch board itself. In this documentation, boards are usually referred to by their i2c channel. Channel 1 is closest to the ft2232h chip, and the channels increase clockwise, until channel 9 at the end.
  
Note that to actually figure out where channel is given it's i2c address, see :py:attr:`i2c_cmd.PhasedArray.addrs`. (it's more clear to look directly at the `i2c_cmd.py` source file). Looking at the array from behind, this 2D array maps the piezo position to the i2c address of the board that controls it.

Make sure the tx/rx switch has the corresponding BNC wired to each channel board, and the channel board PAout is hooked up to the channelboard. Only one Channelboard's tx/rx switch needs to be hooked up to the AB input on the central board (we used channel 1).


Software
~~~~~~~~

Python
------

On the python side, you should be working in a `virtual environment`_. Verify you have an up-to-date python installation (I used python 3.9.6) and then, in a mac/linux shell in the ``scripts`` directory of the repository, run:

.. code-block:: console
		
   python -m venv venv_array
   source venv_array/bin/activate
   pip install -r requirements.txt

To create and activate the venv with all dependencies. Note that the commands in windows are slightly different, particularly the activation in the middle line. I believe running the ``activate.bat`` file in ``venv_array/bin/`` will suffice there.

Lastly, there is some additional setup for `pftdi` to install the proper USB drivers: `install instructions`_

.. _`virtual environment`: https://docs.python.org/3/tutorial/venv.html
.. _`install instructions`: https://eblot.github.io/pyftdi/installation.html#prerequisites

Sam4s development
-----------------

To program the channel boards themselves, we use `Microchip studio`_, which unfortunately only works on Windows. Over summer '21, we used an E79 laptop to run this.

Open the ``.atsln`` ("atmel solution", atmel being the name for the company that made the SAM4S before it got acquired) project file to get started.

We've tried to, for the most part, stick to using the `"Advanced Software Framework"`_ (ASF), which is a Hardware Abstraction Layer (HAL) that should, theoretically, ease development. In reality, while it does sometimes help to provide a board-agnostic layer, and is certainly helpful in some cases, it often causes trouble, and in reality, when bringing up (or modifying) peripherals, an in-depth understanding of the peripheral's user interface is usually needed. The `SAM4s datasheet`_ has good documentation of the SAM4s, and there exists a website do document ASF_ as well. In practice, it is also helpful to use the "go to definition" feature in Microchip Studio to open the ASF file where the function is implemented in the first place and get an idea of what is going on, since the ASF documentation is unclear.

Note that we bypass the ASF in the case of the ``PIOA`` interrupt handler, because the ASF-provided interrupt handler is super bloated. We replace the interrupt vector table (table containing all of the addresses to interrupt handlers) in order to bypass this. See comments in the ``src/main.c`` file itself for info. This file contains everything except for the clock configuration, which can be found in ``src/config/conf_clock.h``, and the crc calculation code taken from the internet (in public domain), which can be found in ``lib/crc.h``

To use a new peripheral for the first time, the specific module first needs to be loaded using the "ASF Wizard".

.. _`Microchip studio`: https://www.microchip.com/en-us/development-tools-tools-and-software/microchip-studio-for-avr-and-sam-devices#tabs
.. _`"Advanced Software Framework"`: https://asf.microchip.com/docs/latest/search.html?device=sam4s
.. _`SAM4s datasheet`: https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-11100-32-bit%20Cortex-M4-Microcontroller-SAM4S_Datasheet.pdf
.. _ASF: https://asf.microchip.com/docs/latest/search.html?device=sam4s


To actually program the sam4s, you need to use the Jlink programmer. Go `tools > device programming` to select the options for this. Make sure that everything is wired right and connected by reading the voltage of the bus, and it should be 3.3v. Then you can try reading the device ID.

The cable/connector used to connect to the MCU is often kind of sketchy, so don't freak out if it cannot connect. Try moving the connector around, or even pulling it out halfway, which often improves the connection.

Note that you need to set the specific flavor of SAM4s MCU that you are using before you can program it, because it checks the device ID. Most channel boards (1-7) have the ``SAM4S4B`` MCU, but the last two have ``SAM4SA16B`` MCUs since they were assembled during the chip-shortage following the pandemic when the other MCUs were no longer available. They are pin-compatible, follow the same datasheet, and the only real difference is memory/flash size and the existence of a special cache that we don't use.

Remember when programming all channel boards that you need to change the i2c address when you change the board you're programming!! An easy way to check that you didn't mess this up is try running ``python -i i2c_cmd.py`` and see if the instantiation of the PhasedArray object chokes up when addressing the channel boards to write DAC values.


Documentation
~~~~~~~~~~~~~

Building this doc uses sphinx. Ensure the python venv is activated, and, in the ``doc`` folder, run ``make clean; make html`` in a terminal to build. all files should appear in ``doc/build``.

The pip packages ``sphinx`` and ``sphinx_rtd_theme`` are required to build this documentation, as well as python packages required to import the documented modules: ``matplotlib``, ``numpy``, and ``pyftdi``.
