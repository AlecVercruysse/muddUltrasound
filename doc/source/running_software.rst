================
Running Software
================

We communicate with the nine channel boards with a host PC and a FTDI FT2232H-56Q evaluation board, which contains an FTDI FT2232H USB to I2C device. All python software is written to run on the host PC.

This API documentation provides the docstrings for the methods used to interact with the Phased Array through the FT2232H chip. All PC to board and board to PC communication is done with methods in the `i2c_cmd` module. Also documented here is `das_scan`, which is the module that contains all of the different imaging scripts, and `visualize`, which is the module that allows "replay" of the imaging done in `das_scan`.

All of these modules are located in the ``scripts/`` directory, and can be run themselves (not just imported).

.. _ref-software:

Communicating with the Array
----------------------------

Wiring
~~~~~~

See below for i2c wiring (also documented in pyftdi_)

.. _pyftdi: https://eblot.github.io/pyftdi/api/i2c.html#wiring
.. _`pyftdi documentation`: https://eblot.github.io/pyftdi/api/i2c.html#open-collector-bus 


.. figure:: figs/i2c_wiring.png
  :width: 400
  :alt: I2C wiring

  Fig.1: FT2232H i2c wiring. note the `FT_` prefix won't appear on the silkscreen of the `FT2232H-56Q` itself.


The SYNC pulse is also generated by the GPIO of the `FT2232H`, and is used by all boards to start a TX operation at the exact same time, and an RX operation at the exact same time. This extremely important to the operation of the phased array since any time difference between the start of the TX or RX operations for different boards will cause destructive phase differences during beamforming. The internal oscillators in the microcontrollers have some frequency offset relative to each other, so the FT2232H provides a SYNC pulse to trigger both the start of the TX and start of the RX operations. The rising edge of the SYNC pulse controls the start of the TX operation, and the falling edge controls the start of the RX operation. We need to have a deterministic and precise amount of time between the start of a TX and the start of an RX, since this delay has to be taken into account when range-finding. Furthermore, we want to be able vary the amount of time between the start of a TX and the start of an RX sequence, since having some delay between the end of the TX and the start of the RX allows the piezos to stop "ringing" before receiving the echo signals. This affects the minimum range that the phased array can image. The FT2232H cannot provide the deterministic timing for the SYNC pulse because it is controlled via USB by a non real time operating system (e.g. the host computer), so the pulse width is non-deterministic. We solve this by using a 555 timer in a `monostable configuration`_, with a trim potentiometer to allow us to vary the pulse width. The 555 timer is triggered by a GPIO output of the FT2232H. In our implementation, the 556 timer was tuned to a 800 us delay. If this is changed, ``PhasedArray.delay`` should be set to what it is tuned to in ``i2c_cmd.py``.

.. _`monostable configuration`: https://www.electronics-tutorials.ws/waveforms/555_timer.html

.. figure:: figs/556_wiring.png
  :width: 400
  :alt: 555/556 wiring for SYNC pulse generation.

  Fig.2: 555/556 wiring for SYNC pulse generation.
  

The wiring schematic file can be found in ``./figs/fish-n-chips-ft2232h``.

Software Setup
~~~~~~~~~~~~~~

To run the python code, first set up a virtual environment using the provided ``requirements.txt``. Note that ``pyfti`` is used to interface with the FTDI FT2232H-56Q evaluation board.

Ensure the FTDI chip is connected via USB to the host PC. Running ``python -i i2c_cmd.py`` will start python in interactive mode, and `i2c_cmd` will create a `PhasedArray` and `ChannelBoard` object for the user to interact with. Running this is the simplest way to check that the host PC is able to communicate with each channel board.

Once the `ChannelBoard` object is instantiated, `i2c_cmd` facilitates simple analog front-end (AFE) debugging. For example, ``ChannelBoard.write(BoardApi.START_PWM)`` will indefinitely turn on the PWM for the instantiated channel board. In the REPL, see ``help(PhasedArray)``, ``help(ChannelBoard)``, and ``help(BoardAPI)`` for more options.

To facilitate debugging the receive analog front end, `read_frambuffer.py` enables simple visualization of samples recorded by the ADC of a channel board. Run ``python3 read_framebuffer.py -h`` for usage information.

.. note:: The i2c read/writes fail occasionally, and we make sure to allow for many re-tries when things go wrong, as well as check the integrity of read data with a crc32 checksum. If an i2c or checksum error occurs, it usually resolves within 10 tries, but very rarely takes longer.


.. _ref-imaging:

Imaging
-------

All the code for the different types of swept-beam imaging is housed in ``das_scan.py``. Note that each type of imaging takes a very long time -- points are scanned in a 2D or 3D space by sending a steered transmit pulse and performing beamforming on the receive. The time taken to perform each set of transmit/receive is limited mostly by the slow speed of the i2c communication.

Running `das_scan.py` as main will run a spherical imaging script. Note that there will be a prompt for the "setup:", which is simply a note the user can write in order to name or comment on the specific image run being taken, for when the captured data is later analyzed.

Logging is enabled by default into a directory called `data/` (relative to the `scripts/` directory). Running `visualize.py`  allows the user to interactively select and view an imaging run to inspect and review.

To run a 2D scan, try running the ``scan_x_slice`` function that `das_scan` provides. There is no raw data logging option for this yet.


File Structure
--------------

.. code:: text

          - scripts/
            - das_scan.py         <- The top-level code for swept-beam imaging.
            - i2c_cmd.py          <- The code containing the interface to each channel board.
            - image.py            <- The code to perform delay-sum beamforming.
            - phaseshifts.py      <- The code to calculate phase shifts for steering directions.
            - read_framebuffer.py <- Debug code to visualize the output of an ADC capture.
            - requirements.txt    <- Used to set up a virtual environment with the necessary python packages.
            - visualize.py        <- Used to visualize (e.g. replay) logged data from das_scan.



.. _ref-api:
              
API Documentation
-----------------

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   api/i2c_cmd
   api/das_scan
   api/visualize


-- Alec Vercruysse
